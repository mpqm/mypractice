package ch3_object_oriented;
//1. 절차지향 프로그래밍 언어
//절차지향 프로그래밍 언어는 프로시저(프로그램 처리 절차)의 호출 개념에 바탕
//프로시저는 전체 애플리케이션을 구성하는 부분을 말하는 것으로, 필요한 기능을 구현한 각각의 함수를 호출한 결과로 다음 작업을 진행하는 구조. ex) C언어, 포트란Fortran, 베이직Basic 등

//2. 객체지향 프로그래밍 언어
//객체지향이란 현실 세계의 객체 모델을 바탕으로 프로그램을 구조화하고 개발하는 프로그래밍 기법, 프로그래밍을 현실 세계의 시각으로 접근
//객체는 하나의 독립적인 개체로, 함수와 유사한 메서드(Method)와 속성으로 구성
//상속, 추상화, 캡슐화 등 객체지향의 특징을 활용한 구조적이고 재활용 가능한 모듈화로 생산성과 유지보수 효율성을 높인 프로그래밍 언어, ex)스몰토크(SmallTalk), C++, C#, 자바, 파이썬(Python)

//3. 절차지향 프로그래밍 과 객체지향 프로그래밍언어의 차이점
//호출단위: 함수 <-> 메서드
//처리단위: 모듈(함수) <-> 객체
//데이터 저장: 변수 <-> 속성
//확장: 라이브러리 <-> 라이브러리. 상속, 추상 클래스, 인터페이스

//4. 객체
//객체를 뜻하는 ‘Object’는 기본적으로는 ‘사물’이라고 해석, 사물은 우리 눈에 보이는 모든 것을 말하며, 그 사물이 가진 속성(Attribute)과 행위(Behavior)로 설명할 수 있는 대상
//객체를 정의하는 작업은 단순하지 않기 때문에 객체들을 일반화(추상화)하거나 구체화하는 작업을 병행

//5. 클래스
//기본구조 : 한정자 class 클래스이름 extends 슈퍼클래스이름 implements 인터페이스이름{}
//속성이 같은 객체들을 대표할 수 있는 대상을 클래스(Class), 객체를 정의하는 틀이며, 필드(속성)와 메서드(행위)로 구성.
//클래스는 추상화로 슈퍼 클래스(상위 클래스, 부모 클래스)와 서브 클래스(하위 클래스, 자식 클래스)로 구분.
//클래스 이름 작성하는 규칙 : 숫자로 시작X, 클래스의 성격을 짐작할 만한 의미있는 간결한 이름으로 선정. 첫 글자는 대문자로 시작. 둘 이상의 단어가 연결되어 있을 때는 두 번째 단어의 첫 글자도 대문자로 한다. 이를 Camel Case라고 한다.

//5-1. 클래스 필드
//필드 기본구조: 한정자 자료형 필드이름(변수이름)
//필드는 객체지향 개념에서 속성에 해당하는 것으로, 멤버 변수라고도 한다. 한정자의 사용이 가능

//5-2. 클래스 메서드
//메서드 기본구조: 한정자 리턴자료형 메서드이름 (파라미터) {return ~~}
//객체지향 개념에서 기능에 해당하는 것으로, 클래스를 사용하여 실행할 수 있는 여러 동작을 구현하는 부분
//동일한 이름으로 서로 다른 파라미터가 포함된 메서드(메서드 오버로딩)를 가질 수 있으며, 상속받은 메서드를 재정의 (메서드 오버라이딩)이 가능
//메서드 역시 한정자의 사용이 가능하며, 자바에서는 리턴 값을 반드시 명시해야 한다

//5-3. 클래스 접근한정자 
//public: 모든 클래스에서 접근이 가능하다.
//protected: 동일 패키지에 속한 클래스 및 서브 클래스에서 접근이 가능하다
//default: 동일 패키지에 속한 클래스에서만 접근을 허용한다. 기본값으로, 한정자를 쓰지않는 경우이다
//private: 현재 클래스에서만 접근이 가능하다
//접근영역: public>protected>default>private

//5-4. 클래스 일반한정자
//static: 클래스 메서드와 클래스 변수를 선언하는 데 사용한다. static은 자바의 정적 영역에 할당되는 리소스를 선언하는 데 사용하며, 동일 가상머신상에서 실행 중인 모든 클래스에서 공유한다. 인스턴스를 성하지 않고도 클래스의 메서드나 멤버에 접근할 수 있다
//final: 더 이상 변경할 수 없도록 선언하는 한정자이다. 클래스에 사용할 때는 서브 클래스를 만들 수 없고, 메서드에 사용할 때는 오버라이딩을 할 수 없다. 변수에 사용하면 변수에 저장된 값이 변할 수 없으므로 변수가 아닌 상수의 역할을 한다
//abstract: 추상 클래스(추상 메서드를 포함하는 클래스)를 선언하는 데 사용하는 한정자이다
//synchronized/volatile: 둘 다 스레드 프로그래밍에서 여러 스레드가 동시에 자원에 접근할 때 발생하는 데이터 동기화를 처리하는 한정자이다

//6. 인스턴스
//인스턴스 기본구조: 클래스이름 참조변수 = new 클래스이름()(생성자)
//인스턴스는 클래스에서 생성한 객체로, 고유한 상태가 있음, 객체와 동일하게 여겨도 됨
//참조 변수는 클래스를 바탕으로 생성한 자바 객체를 프로그램에서 사용하는 데 필요한 변수 (배열, 문자열도 참조 변수로 관리)

//6-1. 인스턴스의 생성자
//기본구조 : 접근 한정자 생성자 이름 (파라미터) {}
//생성자는 클래스나 인스턴스를 생성할 때 호출하는 특수한 목적의 메서드, 보통 객체를 생성할 때 변수를 초기화하거나 필요한 다른 객체를 생성하는 등 작업을 처리
//접근 한정자: public, private, protected(생성자에는 abstract, final, native, static, synchronized 등을 사용할 수 없음)
//생성자 이름: 반드시 클래스 이름과 동일하게 작성해야 한다, 생성자의 특징 중 하나로, 이름이 다르면 생성자가 아닌 일반 메서드로 인식
//파라미터: 일반적인 메서드처럼 생성자도 파라미터를 가진다, 파라미터에는 제약 없이 값을 넣을 수 있지만, 생성자에 정의된 파라미터를 동일하게 전달해야만 객체 생성이 가능
//특징: 리턴값이X 따라서 void를 비롯한 리턴값의 데이터형을 입력하면 안됨
//     파라미터가 있는 다른 여러 생성자를 정의할 수 있다(메서드 오버로딩)
//     파라미터가 없는 기본 생성자는 특별히 생성자에서 처리해야 하는 일이 없다면 굳이 프로그램에서 구현할 필요가 없다. 다만 생성자를 여러 개 정의할 때는 반드시 기본 생성자를 명시해야 기본 생성자로 객체 생성이 가능

//*인스턴스 변수는 인스턴스로만 접근이 가능한 변수, 클래스 변수는 인스턴스를 생성하지 않아도 접근 가능한 변수.

//7. 상속
//상속은 클래스를 추상화 하거나 구체화하는 과정에서 발생. 
//상속을 이용하면 슈퍼 클래스의 기본 구성 요소(필드, 메서드)를 물려받으며(상속), 자신만의 필드나 메서드를 추가하여 구체화하는 것이 가능하다. 물론 물려받은 메서드의 내용을수정하는 것도 가능
//클래스는 추상화된 슈퍼 클래스와 구체화된 서브 클래스로 구성한다. 그리고 슈퍼 클래스와 서브 클래스의 관계를 상속이라고 한다. 자바에서는 다른 객체지향 언어와 달리 다중 상속을 지원하지 않는다

//8. 캡슐화
//캡슐화는 생성한 객체를 어떤 메서드와 필드로 어떻게 일을 수행할지 외부에 숨기는 특성

//9. 다형성
//클래스의 상속 관계를 이용하여 슈퍼 클래스가 같은 서브 클래스들이 동일한 요청을 다르게 처리할 수 있는 특징. 실제 프로그램에서는 메서드를 오버라이딩(재정의)하여 구현.

//10. static과 main( )메서드
//static으로 선언된 변수들은 각 인스턴스 안에서 공유함, 더 나아가 인스턴스를 생성하지 않아도 사용가능, 메서드도 변수와 동일하게 인스턴스를 생성하지 않아도 해당 메서드를 바로 사용가능
//클래스를 만들 때 모든 인스턴스에서 공통된 값을 사용해야 할 때는 static을 이용, static 메서드 안에서는 static 변수만 사용 가능, main( ) 메서드 안에서는 클래스에 선언된 일반 멤버 변수를 사용할 수 없음
//자바가상머신의 메모리구조 : 메서드영역(메서드 바이트코드, 클래스변수), 힙영역(자바객체, 인스턴스 변수), 스택영역(메서드 파라미터, 지역변수)
//특정 기능 제공을 목적으로 하는 라이브러리 클래스를 만들 때 클래스 안에서 인스턴스 변수를 사용하지 않는다면 메서드에 static 사용을 고려할 만하다. 단순히 특정 메서드만 사용하려고 모든 클래스를 매번 인스턴스로 생성하는 것은 비효율적이다

//11. 추상 클래스와 인터페이스
//추상 클래스와 인터페이스는 객체지향 개념을 실제 프로그램 개발에 쉽게 적용하고 유연한 설계를 지원하는 요소

//11-1. 추상클래스
//일반 클래스보다 추상적인 관점에서 접근. 구체적인 내용보다는 기본적인 속성과 필요한메서드의 형태(프로토 타입)만 기술하고 세부적인 구현은 구현하는 클래스에서 담당하도록 하는 형태
//추상 클래스는 기본 구조, 기능과 함께 다른 기능에 대한 규격을 함께 제공하는 형태, 인터페이스는 기본적인 구조를 포함한 전체 규격(설계서)만 제공하는 형태
//추상클래스 특징: 추상 메서드(구현되지 않고 정의만 한 메서드)를 하나 이상 포함한다. 추상 메서드가 포함된 클래스는 반드시 추상클래스로 정의해야 한다. 추상 클래스는 일반 클래스와 같이 멤버 변수 및 메서드를 포함할 수 있다
//             추상 클래스는 그 자체를 인스턴스화, 즉 객체 생성에 사용할 수 없으며, 반드시 추상 클래스를 상속받는 클래스를 만든 후 추상 클래스에 선언된 모든 추상 메서드를 오버라이딩해서 구현해야 한다.
//추상클래스 사용하는 이유: 프로그램을 구체적으로 어떻게 구현할지 확신이 없거나 개발자에 따라 자유롭게 구현하도록 내버려 두되 프로그램을 동일한 규격으로 만들 수 있도록 가이드를 제공하려고 사용하는 것

//11-2. 인터페이스
//인터페이스는 일반 메서드를 포함할 수 없으며, 모두 추상 메서드(public abstract)로만 구성해야 한다.
//일반 멤버 필드는 없고, public, static, final로 선언한 상수만 있다.
//추상 클래스와 마찬가지로 직접 객체를 생성하는 것은 불가능하고, 다른 클래스로 구현할 때는 implements 키워드로 구현을 선언해야 한다.
//클래스 상속과는 별도로 동작하므로 문법상 다중 상속을 지원하지 않는 자바에서 다중 상속의 개념을 지원하는 형태로 사용하는 것이 가능하다

//12. 메서드 오버로딩
//메서드 오버로딩메서드 이름은 동일하지만 파라미터가 다른 여러 메서드를 만드는 것을 말한다
//메서드 오버로딩의 조건: 메서드 이름이 같아야 한다. 파라미터의 개수 또는 자료형이 달라야 한다. 파라미터는 같고 리턴 변수의 자료형이 다르면 오버로딩이 성립되지 않는다.

//13. 메서드 오버라이딩
//슈퍼 클래스에서 정의한 메서드를 서브 클래스에서 재정의하는 것
//슈퍼 클래스에서 정의한 어떤 메서드의 내용이 서브 클래스에 적합하지 않거나 새롭게 변경된 내용이 있을 때 사용.
//메서드 오버로딩 조건: 오버라이딩하는 메서드는 슈퍼 클래스의 메서드와 메서드 구성 요소 모두가 동일해야 한다. 이때 이름, 파라미터, 리턴 타입이 모두 같아야 한다

//14. 패키지
//패키지는 동일한 성격이나 목적에 따라 클래스들을 묶어서 관리하는 자바 규격이다 ex)java.io, java.net, java.util, java.lang
